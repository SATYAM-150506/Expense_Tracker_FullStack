# LOW-LEVEL DESIGN (LLD) - EXPENSE TRACKER

## 1. Introduction

This document provides a detailed, component-level design for the Expense Tracker application. It breaks down the High-Level Design into specific implementation details, including data structures, algorithms, class hierarchies, function signatures, and database schemas.

---

## 2. Backend Architecture Details

### 2.1 Server Configuration & Initialization

**File:** `backend/server.js`

**Responsibilities:**
- Initialize Express application
- Connect to MongoDB
- Load environment variables
- Register middleware stack
- Mount routes
- Implement error handling

**Implementation Details:**

```
server.js
├── Initialize Express App
├── Load Environment Variables (dotenv)
├── Configure CORS Middleware
│   └── Allow origin: FRONTEND_URL (env variable)
├── Configure Body Parser Middleware
│   ├── JSON parser (express.json())
│   └── URL-encoded parser (express.urlencoded())
├── Register Route Handlers
│   ├── /api/auth → auth routes
│   └── /api/expenses → expenses routes
├── Error Handling Middleware
│   ├── Global error handler (4 parameters: err, req, res, next)
│   └── 404 Not Found handler
└── MongoDB Connection
    ├── mongoose.connect() with MONGODB_URI
    ├── Connection success log
    └── Connection error handling (process.exit(1))

Startup Flow:
1. dotenv.config() loads .env file
2. Express app initialized
3. Middleware registered in order
4. Routes mounted
5. connectDB() called
6. Server listens on PORT (default: 5000)
```

---

### 2.2 User Model & Schema

**File:** `backend/models/User.js`

**Database Collection:** `users`

**Schema Definition:**

```javascript
UserSchema = {
  _id: ObjectId (auto-generated by MongoDB),
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 50,
    validation: "Non-empty string, max 50 characters"
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    match: "/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/",
    validation: "Valid email format, unique in collection"
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
    select: false,
    validation: "Min 6 characters, hashed with bcryptjs",
    note: "select:false means not returned by default in queries"
  },
  createdAt: {
    type: Date,
    default: Date.now,
    auto: true
  },
  updatedAt: {
    type: Date,
    auto: true
  }
}
```

**Pre-save Hooks:**

```
PRE-SAVE HOOK: userSchema.pre('save', async function(next))
├── Check if password field is modified
│   ├── If NOT modified: call next() and skip hashing
│   └── If modified: proceed to hashing
├── Generate salt: await bcrypt.genSalt(10)
│   └── Salt rounds: 10 (computational cost)
├── Hash password: await bcrypt.hash(this.password, salt)
├── Update this.password with hashed value
└── Call next() to complete save
```

**Instance Methods:**

```
METHOD: matchPassword(enteredPassword)
├── Input: Plain text password from user login
├── Process: 
│   └── await bcrypt.compare(enteredPassword, this.password)
├── Output: Boolean (true if passwords match, false otherwise)
└── Usage: During login to verify credentials
```

---

### 2.3 Expense Model & Schema

**File:** `backend/models/Expense.js`

**Database Collection:** `expenses`

**Schema Definition:**

```javascript
ExpenseSchema = {
  _id: ObjectId (auto-generated),
  user: {
    type: ObjectId,
    ref: 'User',
    required: true,
    validation: "Reference to User document, required"
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100,
    validation: "Non-empty string, max 100 characters"
  },
  amount: {
    type: Number,
    required: true,
    min: 0.01,
    validation: "Must be greater than 0"
  },
  category: {
    type: String,
    required: true,
    enum: [
      'Food',
      'Transportation',
      'Entertainment',
      'Healthcare',
      'Shopping',
      'Bills',
      'Education',
      'Travel',
      'Other'
    ],
    validation: "Must be one of 9 predefined categories"
  },
  description: {
    type: String,
    trim: true,
    maxlength: 500,
    optional: true,
    validation: "Optional, max 500 characters"
  },
  date: {
    type: Date,
    required: true,
    default: Date.now,
    validation: "Date of expense, defaults to current date"
  },
  createdAt: {
    type: Date,
    default: Date.now,
    auto: true
  },
  updatedAt: {
    type: Date,
    auto: true
  }
}
```

**Indexes:**

```
INDEX 1: Compound Index (user, date)
├── Fields: user: 1, date: -1
├── Sort: User ascending, Date descending
├── Purpose: Query all expenses for a user sorted by date
├── Query Optimization: Retrieves user's latest expenses efficiently

No other indexes defined at model level. Database will use:
- Index on _id (default)
- Unique index on User.email (from User model)
```

---

### 2.4 Authentication Routes & Endpoints

**File:** `backend/routes/auth.js`

**Endpoints:**

#### Endpoint 1: POST /api/auth/register

```
Route: POST /api/auth/register

Request Body:
{
  name: String (required, 1-50 chars),
  email: String (required, valid email format),
  password: String (required, min 6 chars)
}

Validation Pipeline:
1. Input validation
   ├── body('name').notEmpty().trim().isLength({ max: 50 })
   ├── body('email').isEmail().normalizeEmail()
   └── body('password').isLength({ min: 6 })

2. Check if user already exists
   └── User.findOne({ email: email })
       ├── If exists: Return 400 error "User already registered"
       └── If not exists: Proceed

3. Create new user
   ├── const user = new User({ name, email, password })
   ├── Hash password (pre-save hook triggered)
   ├── await user.save()
   └── Returns: User object with _id, name, email, createdAt

4. Generate JWT Token
   ├── Input: user._id
   ├── Secret: process.env.JWT_SECRET
   ├── Expiration: 30 days
   └── Returns: token string

Response: 201 Created
{
  success: true,
  token: "eyJhbGciOiJIUzI1NiIs...",
  user: {
    _id: ObjectId,
    name: String,
    email: String,
    createdAt: Date
  }
}

Error Responses:
├── 400 Bad Request: Invalid input validation
├── 400 Bad Request: User already registered
└── 500 Internal Server Error: Database or server error
```

#### Endpoint 2: POST /api/auth/login

```
Route: POST /api/auth/login

Request Body:
{
  email: String (required, valid email format),
  password: String (required)
}

Validation Pipeline:
1. Input validation
   ├── body('email').isEmail().normalizeEmail()
   └── body('password').notEmpty()

2. Find user by email
   ├── User.findOne({ email: email }).select('+password')
   ├── Note: select('+password') overrides select: false
   ├── If not found: Return 401 "Invalid email or password"
   └── If found: Proceed

3. Compare passwords
   ├── Call user.matchPassword(enteredPassword)
   ├── Uses bcrypt.compare() internally
   ├── If false: Return 401 "Invalid email or password"
   └── If true: Proceed

4. Generate JWT Token
   ├── Same as registration
   ├── Secret: process.env.JWT_SECRET
   └── Expiration: 30 days

Response: 200 OK
{
  success: true,
  token: "eyJhbGciOiJIUzI1NiIs...",
  user: {
    _id: ObjectId,
    name: String,
    email: String
  }
}

Error Responses:
├── 400 Bad Request: Invalid input validation
├── 401 Unauthorized: Invalid email or password
└── 500 Internal Server Error: Database or server error
```

#### Endpoint 3: GET /api/auth/profile

```
Route: GET /api/auth/profile
Middleware: Authentication (JWT verify)

Headers:
{
  Authorization: "Bearer <token>"
}

Validation Pipeline:
1. JWT Verification (Authentication Middleware)
   ├── Extract token from Authorization header
   ├── Verify token with JWT_SECRET
   ├── If invalid/expired: Return 401 "Not authenticated"
   ├── If valid: Extract user._id and attach to req.user
   └── Proceed to route handler

2. Fetch user profile
   ├── User.findById(req.user.id)
   ├── Does NOT include password
   └── If not found: Return 404 "User not found"

Response: 200 OK
{
  success: true,
  user: {
    _id: ObjectId,
    name: String,
    email: String,
    createdAt: Date,
    updatedAt: Date
  }
}

Error Responses:
├── 401 Unauthorized: No token or invalid token
├── 404 Not Found: User not found
└── 500 Internal Server Error: Server error
```

---

### 2.5 Authentication Middleware

**File:** `backend/middleware/auth.js`

**Purpose:** Verify JWT tokens and authenticate requests

```
MIDDLEWARE FUNCTION: protect(req, res, next)

Execution Flow:
1. Extract Token
   ├── Get Authorization header: req.headers.authorization
   ├── Check format: "Bearer <token>"
   ├── If format invalid or no token: Return 401 "Not authenticated"
   └── Extract token from "Bearer <token>" string

2. Verify Token
   ├── Call jwt.verify(token, process.env.JWT_SECRET)
   ├── If error (invalid/expired): Return 401
   └── If valid: Decode and extract decoded.id

3. Attach User to Request
   ├── req.user = { id: decoded.id }
   ├── Makes user accessible to next middleware/route handler
   └── Proceed by calling next()

4. Error Handling
   ├── Token missing: "Not authenticated"
   ├── Token invalid/expired: "Not authenticated"
   └── Other errors: "Authentication failed"

Usage in Routes:
router.get('/profile', protect, (req, res) => {
  // At this point, req.user.id contains authenticated user ID
});
```

---

### 2.6 Expense Routes & Endpoints

**File:** `backend/routes/expenses.js`

#### Endpoint 1: POST /api/expenses (Create Expense)

```
Route: POST /api/expenses
Middleware: Authentication

Request Body:
{
  title: String (required, 1-100 chars),
  amount: Number (required, > 0),
  category: String (required, enum of 9 values),
  description: String (optional, max 500 chars),
  date: Date (optional, defaults to now)
}

Validation Pipeline:
1. Input validation
   ├── body('title').notEmpty().trim().isLength({ max: 100 })
   ├── body('amount').isFloat({ min: 0.01 })
   ├── body('category').isIn([list of 9 categories])
   ├── body('description').optional().isLength({ max: 500 })
   └── body('date').optional().isISO8601()

2. Create expense document
   ├── const expense = new Expense({
   │   user: req.user.id,
   │   title,
   │   amount,
   │   category,
   │   description,
   │   date: date || Date.now
   │ })
   ├── await expense.save()
   └── MongoDB automatically sets createdAt, updatedAt

3. Populate user reference (optional)
   └── expense.populate('user', 'name email')

Response: 201 Created
{
  success: true,
  expense: {
    _id: ObjectId,
    user: ObjectId,
    title: String,
    amount: Number,
    category: String,
    description: String,
    date: Date,
    createdAt: Date,
    updatedAt: Date
  }
}

Error Responses:
├── 400 Bad Request: Validation failed
├── 401 Unauthorized: Not authenticated
└── 500 Internal Server Error: Database error
```

#### Endpoint 2: GET /api/expenses (Get All Expenses with Filters)

```
Route: GET /api/expenses
Middleware: Authentication
Query Parameters: category (optional), startDate (optional), endDate (optional)

Query Example: GET /api/expenses?category=Food&startDate=2024-01-01&endDate=2024-12-31

Processing Pipeline:
1. Build MongoDB Query
   ├── Base query: { user: req.user.id }
   ├── If category provided:
   │   └── Add: { category: req.query.category }
   ├── If startDate and/or endDate provided:
   │   ├── date: { $gte: new Date(startDate), $lte: new Date(endDate) }
   │   └── Only include provided date bounds
   └── Final query: { user: ObjectId, ...filters }

2. Execute Query
   ├── Expense.find(query)
   ├── .sort({ date: -1 })  // Most recent first
   ├── .exec()
   └── Returns: Array of expense documents

3. Build Response
   ├── Total expenses: expenses.length
   ├── Total amount: expenses.reduce(sum of amounts)
   └── Category breakdown: Group by category

Response: 200 OK
{
  success: true,
  count: Number,
  total: Number,
  expenses: [
    {
      _id: ObjectId,
      user: ObjectId,
      title: String,
      amount: Number,
      category: String,
      description: String,
      date: Date,
      createdAt: Date,
      updatedAt: Date
    },
    ...
  ]
}

Error Responses:
├── 401 Unauthorized: Not authenticated
└── 500 Internal Server Error: Database error
```

#### Endpoint 3: GET /api/expenses/:id (Get Single Expense)

```
Route: GET /api/expenses/:id
Middleware: Authentication
Path Parameters: id (ObjectId)

Processing Pipeline:
1. Validate ObjectId format
   ├── Check if req.params.id is valid MongoDB ObjectId
   ├── If invalid: Return 400 "Invalid expense ID"

2. Find expense
   ├── Expense.findById(req.params.id)
   ├── If not found: Return 404 "Expense not found"

3. Verify ownership
   ├── Check if expense.user === req.user.id
   ├── If not equal: Return 403 "Forbidden - Not your expense"

4. Return expense
   └── Return complete expense document

Response: 200 OK
{
  success: true,
  expense: { ...expense object }
}

Error Responses:
├── 400 Bad Request: Invalid expense ID
├── 401 Unauthorized: Not authenticated
├── 403 Forbidden: Not authorized to access this expense
├── 404 Not Found: Expense not found
└── 500 Internal Server Error: Database error
```

#### Endpoint 4: PUT /api/expenses/:id (Update Expense)

```
Route: PUT /api/expenses/:id
Middleware: Authentication
Path Parameters: id (ObjectId)

Request Body:
{
  title: String (optional),
  amount: Number (optional),
  category: String (optional),
  description: String (optional),
  date: Date (optional)
}

Processing Pipeline:
1. Validate ObjectId format
   ├── If invalid: Return 400

2. Find expense
   ├── Expense.findById(req.params.id)
   ├── If not found: Return 404

3. Verify ownership
   ├── If expense.user !== req.user.id: Return 403

4. Update fields (only provided fields)
   ├── if (title) expense.title = title
   ├── if (amount) expense.amount = amount
   ├── if (category) expense.category = category
   ├── if (description) expense.description = description
   ├── if (date) expense.date = date

5. Validate updated document
   ├── Mongoose schema validation runs
   ├── If invalid: Return 400

6. Save changes
   ├── await expense.save()
   ├── MongoDB auto-updates updatedAt timestamp

Response: 200 OK
{
  success: true,
  expense: { ...updated expense object }
}

Error Responses:
├── 400 Bad Request: Validation failed or invalid ID
├── 401 Unauthorized: Not authenticated
├── 403 Forbidden: Not authorized
├── 404 Not Found: Expense not found
└── 500 Internal Server Error: Database error
```

#### Endpoint 5: DELETE /api/expenses/:id (Delete Expense)

```
Route: DELETE /api/expenses/:id
Middleware: Authentication
Path Parameters: id (ObjectId)

Processing Pipeline:
1. Validate ObjectId format

2. Find expense
   ├── Expense.findById(req.params.id)

3. Verify ownership
   ├── If expense.user !== req.user.id: Return 403

4. Delete expense
   ├── Expense.findByIdAndDelete(req.params.id)
   ├── Permanently removes document from MongoDB
   ├── Returns deleted document

Response: 200 OK
{
  success: true,
  message: "Expense deleted successfully",
  expense: { ...deleted expense object }
}

Error Responses:
├── 400 Bad Request: Invalid ID
├── 401 Unauthorized: Not authenticated
├── 403 Forbidden: Not authorized
├── 404 Not Found: Expense not found
└── 500 Internal Server Error: Database error
```

#### Endpoint 6: GET /api/expenses/stats/summary (Get Analytics)

```
Route: GET /api/expenses/stats/summary
Middleware: Authentication

Processing Pipeline:
1. MongoDB Aggregation Pipeline
   ├── Stage 1: $match - Filter by user
   │   └── { $match: { user: ObjectId(req.user.id) } }
   │
   ├── Stage 2: $group - Calculate totals
   │   └── {
   │       $group: {
   │         _id: null,
   │         totalSpent: { $sum: '$amount' },
   │         totalExpenses: { $sum: 1 },
   │         averageExpense: { $avg: '$amount' },
   │         minExpense: { $min: '$amount' },
   │         maxExpense: { $max: '$amount' }
   │       }
   │     }
   │
   └── Stage 3: $group by category
       └── {
           $group: {
             _id: '$category',
             amount: { $sum: '$amount' },
             count: { $sum: 1 }
           }
         }

2. Execute aggregation
   ├── Expense.aggregate([...stages])
   ├── Results processed in MongoDB for efficiency
   └── Returns aggregated statistics

3. Calculate percentages (in application)
   ├── For each category: (amount / totalSpent) * 100
   ├── Round to 2 decimal places

Response: 200 OK
{
  success: true,
  statistics: {
    totalSpent: Number,
    totalExpenses: Number,
    averageExpense: Number,
    minExpense: Number,
    maxExpense: Number
  },
  categoryBreakdown: [
    {
      category: String,
      amount: Number,
      count: Number,
      percentage: Number (0-100)
    },
    ...
  ]
}

Error Responses:
├── 401 Unauthorized: Not authenticated
└── 500 Internal Server Error: Database error
```

---

## 3. Frontend Architecture Details

### 3.1 React Application Structure

**Main Entry Point:** `frontend/src/index.js`

```
React Application Initialization:
1. Import dependencies
   ├── React, ReactDOM
   ├── App component
   └── Global styles (index.css)

2. Render App to DOM
   ├── ReactDOM.render(<App />, document.getElementById('root'))
   └── Root element in public/index.html

3. Tailwind CSS
   ├── Loaded in index.css
   ├── Provides utility classes for styling
   └── Responsive design support
```

### 3.2 AuthContext - State Management

**File:** `frontend/src/context/AuthContext.js`

```
Context Purpose: Global authentication state management

Provider Structure:
AuthContext = createContext()

useAuth() Custom Hook:
├── Returns: { user, token, login, register, logout, isLoading }
└── Throws error if used outside AuthProvider

AuthProvider Component:
├── Props: children
├── State Variables:
│   ├── user: Current logged-in user object or null
│   ├── token: JWT token from localStorage or null
│   ├── isLoading: Boolean for loading state
│   └── error: Error message if any
│
├── Initial Setup (useEffect on mount):
│   ├── Check localStorage for saved token
│   ├── If token exists:
│   │   ├── Verify token validity
│   │   └── Fetch user profile
│   └── Set user and token state
│
├── login(email, password) Function:
│   ├── Call API.post('/auth/login', { email, password })
│   ├── If success:
│   │   ├── Save token to localStorage
│   │   ├── Set user state
│   │   └── Return success
│   └── If error:
│       ├── Set error state
│       └── Return error
│
├── register(name, email, password) Function:
│   ├── Call API.post('/auth/register', { name, email, password })
│   ├── Auto-login after successful registration
│   └── Same flow as login
│
├── logout() Function:
│   ├── Remove token from localStorage
│   ├── Clear user state
│   └── Reset all auth state
│
└── Value Passed to Context:
    {
      user: user,
      token: token,
      login: login,
      register: register,
      logout: logout,
      isLoading: isLoading
    }
```

### 3.3 API Service Layer

**File:** `frontend/src/services/api.js`

```
Purpose: Centralized API communication

Axios Instance Setup:
├── baseURL: http://localhost:5000/api (or process.env.REACT_APP_API_URL)
├── timeout: 5000ms
└── headers: { 'Content-Type': 'application/json' }

Request Interceptor:
├── Before each request:
│   ├── Get token from localStorage
│   ├── If token exists:
│   │   └── Add header: Authorization: "Bearer <token>"
│   └── Return modified config

Response Interceptor:
├── On success: Return response data
├── On error:
│   ├── If 401 (unauthorized):
│   │   ├── Clear localStorage
│   │   ├── Redirect to login
│   │   └── Clear auth state
│   └── Return error

Exported Methods:
├── AUTH ENDPOINTS:
│   ├── register(name, email, password)
│   │   └── POST /auth/register
│   ├── login(email, password)
│   │   └── POST /auth/login
│   └── getProfile()
│       └── GET /auth/profile
│
├── EXPENSE ENDPOINTS:
│   ├── createExpense(expenseData)
│   │   └── POST /expenses
│   ├── getExpenses(filters)
│   │   └── GET /expenses?category=...&startDate=...&endDate=...
│   ├── getExpenseById(id)
│   │   └── GET /expenses/:id
│   ├── updateExpense(id, expenseData)
│   │   └── PUT /expenses/:id
│   ├── deleteExpense(id)
│   │   └── DELETE /expenses/:id
│   └── getStats()
        └── GET /expenses/stats/summary
```

### 3.4 PrivateRoute Component

**File:** `frontend/src/components/PrivateRoute.js`

```
Purpose: Protect routes that require authentication

Component Structure:
PrivateRoute({ children })
├── Get auth context: const { user, isLoading } = useAuth()
├── If isLoading:
│   └── Return <Loading/> or <div>Loading...</div>
├── If NOT user (not authenticated):
│   └── Return <Navigate to="/login" replace />
│       (Redirects to login page using React Router)
└── If user exists (authenticated):
    └── Return children (renders protected component)

Usage in Router:
<Routes>
  <Route path="/login" element={<Login />} />
  <Route 
    path="/dashboard" 
    element={
      <PrivateRoute>
        <Dashboard />
      </PrivateRoute>
    } 
  />
</Routes>
```

### 3.5 Page Components

#### 3.5.1 Login Page

**File:** `frontend/src/pages/Login.js`

```
Component: Login

State Variables:
├── formData: { email: '', password: '' }
├── error: error message or null
├── loading: boolean for submission state

Handlers:
├── handleChange(e):
│   ├── Update formData with input value
│   └── Clear error on user input
│
├── handleSubmit(e):
│   ├── Prevent default form submission
│   ├── Validate inputs (email format, password length)
│   ├── Call api.login(email, password)
│   ├── If success:
│   │   ├── Update auth context
│   │   └── Navigate to '/dashboard'
│   └── If error:
│       └── Display error message

Form Elements:
├── Email input field
│   ├── type: "email"
│   ├── Required
│   └── Placeholder: "Enter your email"
├── Password input field
│   ├── type: "password"
│   ├── Required
│   └── Placeholder: "Enter your password"
├── Submit button
│   ├── Shows "Logging in..." when loading
│   └── Disabled when loading or invalid form
└── Link to Register page
    └── Text: "Don't have an account? Register here"

Styling: Tailwind CSS
├── Centered card layout
├── Form width: max-w-md
├── Responsive padding and margins
└── Error text in red color
```

#### 3.5.2 Register Page

**File:** `frontend/src/pages/Register.js`

```
Component: Register

State Variables:
├── formData: { name: '', email: '', password: '', confirmPassword: '' }
├── error: error message or null
├── loading: boolean

Validations:
├── Name: Not empty, max 50 chars
├── Email: Valid email format
├── Password: Min 6 characters
├── Confirm Password: Matches password field

Handlers:
├── handleChange(e): Update formData
├── handleSubmit(e):
│   ├── Client-side validation
│   ├── Password confirmation check
│   ├── Call api.register(name, email, password)
│   ├── If success:
│   │   ├── Auto-login with credentials
│   │   └── Navigate to '/dashboard'
│   └── If error:
│       └── Display error message

Form Elements:
├── Name input
├── Email input
├── Password input
├── Confirm Password input
├── Submit button
└── Link to Login page

Error Handling:
├── Display specific validation errors
├── Show server errors from API
└── Clear errors on input change
```

#### 3.5.3 Dashboard Page

**File:** `frontend/src/pages/Dashboard.js`

```
Component: Dashboard (Main page after login)

Layout:
┌─────────────────────────────────────┐
│ Navbar (with logout)                │
├─────────────────────────────────────┤
│ Dashboard Content                   │
│ ├─ ExpenseStats (top)               │
│ ├─ ExpenseForm (add new)             │
│ └─ ExpenseList (all expenses)        │
└─────────────────────────────────────┘

State Variables:
├── expenses: Array of expense objects
├── filters: { category: '', startDate: '', endDate: '' }
├── loading: boolean
├── error: error message or null

Lifecycle:
1. useEffect on mount:
   ├── Fetch all expenses: api.getExpenses()
   └── Set expenses state

2. useEffect on filter change:
   ├── Fetch expenses with filters
   └── Update UI

Handlers:
├── onAddExpense(newExpense):
│   ├── Add to expenses array
│   ├── Refresh statistics
│   └── Show success message
│
├── onDeleteExpense(expenseId):
│   ├── Show confirmation
│   ├── Delete via API
│   ├── Remove from expenses array
│   └── Update statistics
│
├── handleFilterChange(category, dates):
│   ├── Update filters state
│   └── Trigger new fetch with filters

Sub-components Rendered:
├── <ExpenseStats expenses={expenses} />
├── <ExpenseForm onAdd={onAddExpense} />
└── <ExpenseList 
      expenses={expenses} 
      onDelete={onDeleteExpense}
    />
```

#### 3.5.4 AllExpenses Page

**File:** `frontend/src/pages/AllExpenses.js`

```
Component: AllExpenses (Dedicated expense management page)

Features:
├── Display all user expenses in table/card format
├── Filter by category
├── Filter by date range
├── Sort by various fields
├── Quick actions (edit, delete, view)

State Variables:
├── expenses: Array
├── filters: { category, startDate, endDate, sortBy }
├── searchTerm: String for title/description search
├── loading: boolean

Render:
├── Filter Bar
│   ├── Category dropdown
│   ├── Date range picker
│   └── Search input
│
├── Sort Options
│   ├── Sort by Date
│   ├── Sort by Amount
│   └── Sort by Category
│
└── Expense List
    ├── Card or table format
    ├── Show: title, amount, category, date
    └── Actions: Edit, Delete, View Details
```

#### 3.5.5 ExpenseDetail Page

**File:** `frontend/src/pages/ExpenseDetail.js`

```
Component: ExpenseDetail (Single expense view)

Route Parameters:
├── expenseId from URL params

Data Loading:
├── useEffect on mount:
│   ├── Get expenseId from useParams()
│   ├── Fetch single expense: api.getExpenseById(expenseId)
│   └── Set expense state

Display:
├── Header: Expense title
├── Expense details in structured format:
│   ├── Amount (large, prominent)
│   ├── Category (with badge/color)
│   ├── Date
│   ├── Description (if available)
│   └── Created/Updated dates
│
└── Actions:
    ├── Edit button → Navigate to ExpenseForm in edit mode
    ├── Delete button → Confirm and delete
    └── Back button → Return to expenses list

Loading State:
├── Show loading spinner while fetching
└── Show error message if fetch fails

Error Handling:
├── If expense not found: Show 404 message
├── If not authorized: Show 403 message
└── Show error with back/retry options
```

### 3.6 Component Library

#### 3.6.1 Navbar Component

**File:** `frontend/src/components/Navbar.js`

```
Component: Navbar (Header/Navigation)

Props: None (uses AuthContext internally)

Structure:
┌─────────────────────────────────────┐
│ Logo/App Name | Links | User Menu   │
└─────────────────────────────────────┘

Content:
├── Left Section:
│   ├── App Logo/Name "ExpenseTracker"
│   └── Link to Home/Dashboard
│
├── Center Section:
│   ├── Navigation Links (conditionally shown):
│   │   ├── If authenticated:
│   │   │   ├── Dashboard
│   │   │   └── All Expenses
│   │   └── If not authenticated:
│   │       ├── Login
│   │       └── Register
│
└── Right Section:
    ├── If authenticated:
    │   ├── Display user name
    │   └── Logout button
    │       └── onClick: handleLogout()
    │           ├── Call auth.logout()
    │           ├── Clear state
    │           └── Navigate to login
    └── If not authenticated:
        └── Empty or Login/Register links

Styling:
├── Dark background with light text
├── Responsive: hamburger menu on mobile
├── Sticky/fixed positioning
└── Shadow for depth
```

#### 3.6.2 ExpenseForm Component

**File:** `frontend/src/components/ExpenseForm.js`

```
Component: ExpenseForm (Add/Edit expense)

Props:
├── onSubmit: Function to handle form submission
├── initialData: Expense object for edit mode (optional)
├── isLoading: Boolean

State:
├── formData: {
│   title: '',
│   amount: '',
│   category: '',
│   description: '',
│   date: ''
│ }
├── errors: Object with field errors
├── isSubmitting: Boolean

useEffect on initialData change:
├── If initialData exists (edit mode):
│   └── Populate formData with initialData
└── If no initialData (add mode):
    └── Reset formData to empty

Handlers:
├── handleChange(e):
│   ├── Update formData field
│   └── Clear field error
│
├── validateForm():
│   ├── Check all required fields
│   ├── Validate amount > 0
│   ├── Validate category selected
│   ├── Return errors object
│   └── Return isValid boolean
│
├── handleSubmit(e):
│   ├── Prevent default
│   ├── Validate form
│   ├── If invalid: show errors
│   ├── If valid:
│   │   ├── Call onSubmit(formData)
│   │   ├── If success:
│   │   │   ├── Reset form
│   │   │   └── Show success message
│   │   └── If error:
│   │       └── Show error message

Form Fields:
├── Title input
│   ├── type: "text"
│   ├── maxLength: 100
│   ├── Required
│   └── Error message below if invalid
│
├── Amount input
│   ├── type: "number"
│   ├── min: 0.01
│   ├── step: 0.01
│   ├── Required
│   └── Error display
│
├── Category select
│   ├── Options: Food, Transportation, Entertainment, Healthcare, 
│   │            Shopping, Bills, Education, Travel, Other
│   ├── Required
│   └── Error display
│
├── Description textarea
│   ├── maxLength: 500
│   ├── Optional
│   ├── Placeholder: "Add description..."
│   └── Character counter
│
├── Date input
│   ├── type: "date"
│   ├── default: today
│   ├── Cannot be future date
│   └── Optional with default
│
└── Submit button
    ├── Text: initialData ? "Update Expense" : "Add Expense"
    ├── Disabled when loading or invalid
    └── Shows spinner when loading

Styling:
├── Form card layout
├── Responsive grid for fields
├── Input validation styling (red border on error)
├── Success/error toast notifications
└── Tailwind CSS utilities
```

#### 3.6.3 ExpenseList Component

**File:** `frontend/src/components/ExpenseList.js`

```
Component: ExpenseList (Display all expenses)

Props:
├── expenses: Array of expense objects
├── onDelete: Function to handle delete
├── onEdit: Function to handle edit
├── onView: Function to view details
├── loading: Boolean
├── filters: Current filters applied

State:
├── sortBy: 'date' | 'amount' | 'category' (default: 'date')
├── sortOrder: 'asc' | 'desc' (default: 'desc')

Rendering Options:
├── OPTION 1: Card Layout (recommended for dashboard)
│   └── Each expense as individual card:
│       ├── Title
│       ├── Amount (large, prominent)
│       ├── Category (badge with color)
│       ├── Date
│       ├── Quick actions (edit, delete, view)
│       └── Card hover effect
│
└── OPTION 2: Table Layout (for AllExpenses page)
    └── Columns: Date | Title | Category | Amount | Actions

Handlers:
├── handleDelete(expenseId):
│   ├── Show confirmation dialog
│   ├── If confirmed:
│   │   └── Call onDelete(expenseId)
│   └── If cancelled:
│       └── Do nothing
│
├── handleEdit(expenseId):
│   └── Call onEdit(expenseId)
│
├── handleView(expenseId):
│   └── Navigate to /expense/:expenseId
│
├── handleSort(field):
│   ├── If same field clicked: toggle sort order
│   └── If different field: sort by new field (desc)

Empty State:
├── If expenses.length === 0:
│   ├── Show empty state message
│   ├── Icon indicating no data
│   └── Link to "Add your first expense"

Loading State:
├── Show skeleton loaders or spinner
└── Return before rendering list

Error State:
├── Show error message
├── Retry button
└── Back button

Styling:
├── Responsive: Stack on mobile, grid on desktop
├── Category color coding
├── Hover effects on interactive elements
├── Animation on add/delete
└── Tailwind CSS
```

#### 3.6.4 ExpenseStats Component

**File:** `frontend/src/components/ExpenseStats.js`

```
Component: ExpenseStats (Display analytics)

Props:
├── expenses: Array of expense objects

State:
├── stats: { totalSpent, totalCount, average, ... }
├── categoryBreakdown: Array of category data

useEffect:
├── Calculate statistics from expenses array:
│   ├── totalSpent: Sum of all amounts
│   ├── totalCount: Length of expenses array
│   ├── averageExpense: totalSpent / totalCount
│   ├── highestExpense: Max amount
│   ├── lowestExpense: Min amount
│   └── categoryBreakdown: Group by category
│
└── Calculate percentages for each category

Display Layout:
┌────────────────────────────────────────┐
│ Stats Cards Row                        │
├──────────┬──────────┬──────────────────┤
│ Total    │ Count    │ Average          │
│ $XXXX.XX │ XX       │ $XXX.XX          │
└──────────┴──────────┴──────────────────┘

Category Breakdown Section:
├── Category bars (visual representation):
│   ├── Bar length proportional to amount
│   ├── Color coded by category
│   ├── Label with category name
│   ├── Amount spent
│   └── Percentage of total
│
├── Pie chart (alternative visualization):
│   ├── Slice per category
│   ├── Color coding
│   ├── Label with percentage
│   └── Legend below
│
└── Category list (detailed):
    ├── Table or cards format
    ├── Columns: Category | Amount | Count | %
    └── Sorted by amount descending

Styling:
├── Stats cards with icons
├── Color-coded categories:
│   ├── Food: Green
│   ├── Transportation: Blue
│   ├── Entertainment: Purple
│   ├── Healthcare: Red
│   ├── Shopping: Pink
│   ├── Bills: Orange
│   ├── Education: Yellow
│   ├── Travel: Cyan
│   └── Other: Gray
├── Responsive grid layout
└── Tailwind CSS with custom colors

Edge Cases:
├── If no expenses: Show "No expenses yet"
├── If expenses but no breakdown: Show message
└── If data loading: Show skeleton loaders
```

---

## 4. Data Structures & Algorithms

### 4.1 JWT Token Structure

```
JWT Format: header.payload.signature

Header:
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Claims):
{
  "id": ObjectId (user._id),
  "iat": timestamp (issued at),
  "exp": timestamp (expiration - 30 days from now)
}

Signature:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  JWT_SECRET
)

Generation on Login/Register:
const token = jwt.sign(
  { id: user._id },
  process.env.JWT_SECRET,
  { expiresIn: '30d' }
);
```

### 4.2 Password Hashing Algorithm

```
Process:
1. Generate Salt: salt = await bcrypt.genSalt(10)
   ├── Salt rounds: 10
   ├── Higher rounds = more secure but slower
   └── Typical: 8-12 rounds (10 is balanced)

2. Hash Password: hashedPassword = await bcrypt.hash(password, salt)
   ├── Uses bcrypt algorithm
   ├── Irreversible one-way hash
   ├── Salt combined with password
   └── Result: Hash string (~60 characters)

3. Storage: Save hashedPassword to database

4. Verification: match = await bcrypt.compare(plainPassword, hashedPassword)
   ├── Hashes plainPassword with stored salt
   ├── Compares both hashes
   ├── Returns true if match, false otherwise
```

### 4.3 Query Filtering Algorithm

```
Filter Construction (Expenses):
function buildQuery(userId, filters) {
  const query = { user: userId };
  
  if (filters.category) {
    query.category = filters.category;
  }
  
  if (filters.startDate || filters.endDate) {
    query.date = {};
    if (filters.startDate) {
      query.date.$gte = new Date(filters.startDate);
    }
    if (filters.endDate) {
      const endDate = new Date(filters.endDate);
      endDate.setHours(23, 59, 59, 999); // Include entire day
      query.date.$lte = endDate;
    }
  }
  
  return query;
}

Execution:
1. Build MongoDB query object
2. Use indexes for optimized retrieval
3. Mongoose converts to MongoDB query
4. Database executes with index support
5. Results sorted and returned
```

### 4.4 Statistics Aggregation Algorithm

```
MongoDB Aggregation Pipeline:

Stage 1 - Filter by User:
{
  $match: { user: ObjectId(userId) }
}

Stage 2 - Calculate Overall Stats:
{
  $group: {
    _id: null,
    totalSpent: { $sum: '$amount' },
    totalExpenses: { $sum: 1 },
    averageExpense: { $avg: '$amount' },
    minExpense: { $min: '$amount' },
    maxExpense: { $max: '$amount' }
  }
}

Stage 3 - Calculate Category Breakdown:
{
  $group: {
    _id: '$category',
    amount: { $sum: '$amount' },
    count: { $sum: 1 }
  }
}

Stage 4 - Sort by amount:
{
  $sort: { amount: -1 }
}

Processing on Application:
1. Get totalSpent from overall stats
2. For each category:
   percentage = (categoryAmount / totalSpent) * 100
   Round to 2 decimal places
3. Sort categories by percentage descending
4. Format for frontend display

Time Complexity:
├── Aggregation: O(n) where n = number of user's expenses
├── Database execution: Optimized with indexes
└── Network transfer: Efficient JSON serialization
```

---

## 5. Security Architecture

### 5.1 Authentication Flow

```
REGISTRATION FLOW:
1. User enters credentials → Frontend validation
2. POST /api/auth/register → Express server
3. Server validates input (length, format, etc.)
4. Check email uniqueness → Database query
5. Hash password → Bcryptjs pre-save hook
6. Save user → MongoDB insert
7. Generate JWT → jwt.sign() with SECRET
8. Return token → Frontend storage
9. Store in localStorage → Browser storage

LOGIN FLOW:
1. User enters email/password
2. POST /api/auth/login → Express server
3. Server queries user by email
4. Compare passwords → bcrypt.compare()
5. If match: Generate JWT
6. If no match: Return 401 error
7. Return token → Frontend
8. Store in localStorage

AUTHENTICATED REQUEST:
1. Frontend gets token from localStorage
2. Add to Authorization header: "Bearer <token>"
3. axios interceptor adds header automatically
4. POST /api/expenses → Express server
5. Authentication middleware validates token
6. JWT verified with SECRET
7. If valid: Extract user ID, proceed
8. If invalid: Return 401, request login
9. Endpoint executes with authenticated user context
```

### 5.2 Authorization Verification

```
For Each Protected Endpoint:

1. User Ownership Check:
   if (expense.user !== req.user.id) {
     return res.status(403).json({ message: 'Forbidden' });
   }
   // Prevents users from accessing other users' data

2. Data Validation:
   - Server-side validation (not just client)
   - Type checking
   - Range validation
   - Enum validation

3. SQL Injection Prevention:
   - Mongoose ORM (prevents injection)
   - No raw queries with string concatenation
   - Parameterized queries

4. CORS Protection:
   - Only allow requests from FRONTEND_URL
   - Credentials: true for cookies/auth headers
```

---

## 6. Error Handling Strategy

### 6.1 Backend Error Handling

```
Middleware Stack:
1. Route Handlers:
   try {
     // Route logic
   } catch (error) {
     next(error);  // Pass to error handler
   }

2. Validation Errors:
   const errors = validationResult(req);
   if (!errors.isEmpty()) {
     return res.status(400).json({ errors: errors.array() });
   }

3. Global Error Handler:
   app.use((err, req, res, next) => {
     console.error(err.stack);
     const statusCode = err.statusCode || 500;
     const message = err.message || 'Something went wrong!';
     res.status(statusCode).json({ 
       success: false,
       message: message 
     });
   });

Error Types:
├── 400 Bad Request: Validation/input error
├── 401 Unauthorized: Authentication failed
├── 403 Forbidden: Authorization failed
├── 404 Not Found: Resource not found
└── 500 Internal Server Error: Server error
```

### 6.2 Frontend Error Handling

```
Axios Interceptors:
1. Response Interceptor Error:
   if (error.response.status === 401) {
     // Clear auth, redirect to login
     localStorage.removeItem('token');
     AuthContext.logout();
     window.location.href = '/login';
   }

2. User Feedback:
   - Toast notifications for errors
   - Form field error display
   - Global error banners

3. Graceful Degradation:
   - Show user-friendly error messages
   - Provide retry/back options
   - Never show raw server errors
```

---

## 7. Performance Optimization

### 7.1 Database Indexes

```
User Collection:
├── Index on email (unique)
│   └── Fast lookup during login/registration
└── Index on createdAt
    └── For sorting users by creation date

Expense Collection:
├── Compound index on (user, date DESC)
│   └── Optimizes: Get all expenses for user sorted by date
└── Compound index on (user, category)
    └── Optimizes: Get expenses by user and category
```

### 7.2 API Response Optimization

```
Data Serialization:
├── Return only necessary fields
├── Exclude password fields
├── Flatten nested objects when possible
└── Use JSON compression (gzip)

Pagination (Future Enhancement):
├── Limit: 20 expenses per page
├── Offset/Skip for pagination
├── Total count in response
└── Client-side caching
```

### 7.3 Frontend Optimization

```
React Optimization:
├── Memoization: React.memo for pure components
├── useCallback: Prevent unnecessary re-renders
├── useMemo: Cache expensive calculations
├── Code splitting: Lazy load routes
└── Image optimization: Compress images

State Management:
├── Context API (lightweight for this app)
├── Avoid deeply nested state
├── Use local state for component-specific data
└── Only share auth state globally

Network Optimization:
├── Axios request caching (future)
├── Debounce filter inputs
├── Batch requests where possible
└── Minimize API calls
```

---

## 8. Testing Strategy

### 8.1 Backend Testing (Jest/Supertest)

```
Test Categories:

1. Authentication Tests:
   ├── test('Register with valid data - success')
   ├── test('Register with duplicate email - failure')
   ├── test('Login with correct password - success')
   ├── test('Login with wrong password - failure')
   └── test('Get profile with valid token - success')

2. Expense CRUD Tests:
   ├── test('Create expense - success')
   ├── test('Create invalid expense - failure')
   ├── test('Get all user expenses - success')
   ├── test('Update expense - authorized - success')
   ├── test('Update expense - unauthorized - failure')
   ├── test('Delete expense - authorized - success')
   └── test('Delete expense - unauthorized - failure')

3. Authorization Tests:
   ├── test('User cannot access other user expenses')
   ├── test('User cannot modify other user expenses')
   └── test('Protected routes require token')

4. Aggregation Tests:
   ├── test('Get statistics - calculates correctly')
   ├── test('Category breakdown - sums correctly')
   └── test('Statistics with filters')
```

### 8.2 Frontend Testing (React Testing Library)

```
Test Categories:

1. Component Rendering:
   ├── test('Login component renders form')
   ├── test('Dashboard renders with expenses')
   └── test('ExpenseList displays expenses')

2. User Interactions:
   ├── test('Form submission calls API')
   ├── test('Delete button shows confirmation')
   └── test('Filter updates list')

3. State Management:
   ├── test('AuthContext updates on login')
   ├── test('AuthContext clears on logout')
   └── test('Protected routes redirect unauthenticated users')

4. Error Handling:
   ├── test('Display error message on API failure')
   ├── test('Retry button after error')
   └── test('Redirect to login on 401 error')
```

---

## 9. Deployment Architecture

### 9.1 Backend Deployment

```
Environment: Node.js hosting (Heroku, AWS, Azure, etc.)

Configuration:
├── NODE_ENV=production
├── MONGODB_URI=<cloud MongoDB connection string>
├── JWT_SECRET=<strong random secret key>
├── FRONTEND_URL=<production frontend URL>
├── PORT=<dynamic port from process.env.PORT>
└── CORS origin set to production frontend

Production Considerations:
├── Database backups enabled
├── Error logging service (Sentry)
├── Performance monitoring
├── Rate limiting on API endpoints
└── HTTPS/TLS enabled
```

### 9.2 Frontend Deployment

```
Environment: Static hosting (Vercel, Netlify, AWS S3, etc.)

Configuration:
├── REACT_APP_API_URL=<production backend URL>
├── Build command: npm run build
├── Output directory: build/
├── Environment variables in .env.production
└── API endpoints updated for production

Build Optimization:
├── minification enabled
├── source maps disabled in production
├── lazy loading enabled
├── cache headers configured
└── CDN distribution for assets
```

---

## 10. Future Enhancements & Scalability

### 10.1 Planned Features

```
Phase 2 - Mobile Support:
├── React Native application
├── Offline data sync
├── Push notifications
└── Biometric authentication

Phase 3 - Advanced Analytics:
├── Budget alerts and notifications
├── Spending forecasts
├── Recurring expense templates
├── Export to PDF/Excel
└── Custom reports

Phase 4 - Collaboration:
├── Shared expense tracking (families/groups)
├── Expense splitting
├── Payment settlements
└── Permission management

Phase 5 - Integration:
├── Bank API integration
├── Receipt scanning (OCR)
├── Calendar integration
└── Email notifications
```

### 10.2 Scalability Considerations

```
Database Scalability:
├── Connection pooling
├── Read replicas for analytics queries
├── Sharding by user ID for massive scale
└── Archive old expenses for performance

API Scalability:
├── Load balancing across multiple instances
├── Caching layer (Redis)
├── Rate limiting per user
├── Horizontal scaling with microservices

Frontend Scalability:
├── CDN distribution
├── Service workers for offline support
├── Incremental static regeneration
└── Progressive web app (PWA)
```

---

## 11. API Documentation Quick Reference

### Backend API Endpoints Summary

```
BASE_URL: http://localhost:5000/api

AUTHENTICATION:
POST    /auth/register          Create new user
POST    /auth/login             Login user
GET     /auth/profile           Get user profile (protected)

EXPENSES:
POST    /expenses               Create expense (protected)
GET     /expenses               List expenses (protected)
GET     /expenses/:id           Get single expense (protected)
PUT     /expenses/:id           Update expense (protected)
DELETE  /expenses/:id           Delete expense (protected)
GET     /expenses/stats/summary Get analytics (protected)
```

---

## 12. Environment Variables

### Backend .env

```
NODE_ENV=development
PORT=5000
MONGODB_URI=mongodb://localhost:27017/expense_tracker
JWT_SECRET=your_jwt_secret_key_here
FRONTEND_URL=http://localhost:3000
```

### Frontend .env

```
REACT_APP_API_URL=http://localhost:5000/api
```

---

## Conclusion

This LLD document provides comprehensive implementation details for the Expense Tracker application. It covers:

- Backend architecture with detailed endpoint specifications
- Frontend component structure and data flow
- Database schemas and relationships
- Security mechanisms and error handling
- Performance optimization strategies
- Testing and deployment guidelines

Use this document as a blueprint for development, code review, and system understanding.
